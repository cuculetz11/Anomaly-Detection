 Cucu Viorel-Cosmin 314CA

 TEMA #1#

TASK 1 - Detec»õia anomaliilor

    estimate_gaussian(X) - calculez vecorul de medie "mean_values" exact ca o 
    medie aritmetica.Iau toti vectorii x ce au dimensiunea n (m vectorii fiind)
    apoi pentru fiecare pozite din vectorul de medie fac media aritemtica 
    a tuturor elementelor din cei m vectori x de pe aceea pozitie.
    
    Pentru matricea de varianta aplica formula data si obtin o matricea
    de n*n.  


    gaussian_distribution(element_din_X, mean_values, variance) - 
    cu functia aceasta iau cate un vector x din dataset-ul dat si
    folosindu-ma de formula data calculez densiattea de probabilitate
    ca acest elemt aprtine dataset-ului.

    Aici am creat functia "inversa_mat" ce aplica GPP si-mi face matricea 
    upper, apoi elimin toate elementele de deasupra diagonalei, apoi 
    fac ca pe diagonala sa fie doar 1, toate aceste modificari i le fac
    si unei matrici inital "eye"(unitate) in care la final se va regasi
    matricea initala inversata.

    Am creat si functia "calc_det" ce aplica tot GPP ca apoi sa calculez cu
    usurinta determinatul ce se afla pe diagonala principala. 

    multivariate_gaussian(X, mean_values, variances) - iau fiecare 
    element(vector) din X une ii aplic "gaussian_distribution" pentru a
    vedea probabilitatea ficarui element din dataset.


    check_predictions(predictions, truths) - ma ajuta sa stabilesc in functie
    de acesti 2 parametrii urmatoarele chestii:false_pozitives,
    false_negatives, true_pozitives.

    optimal_threshold(truths, probabilitates) - verific 1000 de epsilonuri
    intre cea mai mica si cea mai mare probabilitate apoi folosindu ma de
    functia "check_predictions" si de functia "metrics"(ce imi calculeaza
    precizia recall-ul si parametrul F1) aleg epsilonul, F1 precizia si
    recall-ul optim.


TASK 2 - Kernel Regression
    linear_kernel(x, y, other), polynomial_kernel(x, y, d), 
    gaussian_kernel(x, y, sigma) - functiile utilizate prntru implemantarea
    kernelui

    build_kernel(X, f, f_param) - construiesc matricea de kerneluri ce stiu
    ca e o matrice Gram, aceasta fiind simtrica calcuez doar jumatate din
    elemnte cu ajutorul functiei date ca parametru

    cholesky(A) - exact ca cea de la laborator, in plus fiind doar vectorizarea
    get_lower_inverse(A) - fac inversarea matricei folosindu-ma de G 

    get_prediction_params(K, y, lambda) - calculez parametrii de predictie
    folosindu-ma de formula data in enunt

    eaval_value(x,X,f,f_param) - calculez valoarea de predictie pentru un
    element x din datasetul X folosindu-ma de formula data in enunt si de
    parametrii de predictie calculati anterior.
    

TASK 3 - Generare de text

    Aici explic doar functia in care creez functia stochastica, restul
    sunt clare

    stochastic_matrx(k_secv_corpus, corpus_words, words_set, k_secv_set, k)
    - creez matricea sparse de dimensiunea k_secv_set*words_set, apoi
    fac un dictionar pentru fiecare cuvant din words_set si ii dau un index(
    il fac pentru a stii imediat ce gasesc o litera pe ce coloana a
    matricei se afla)

    Apoi ma plimb prin tot setul meu de k_secv_set ce sunt unice si pe cea de
    la indexul i o caut in k-secv_corpus, apoi cu ajutorul functie find fac
    un vector "k_secv_poz" ce stocheza pozitia din k_secv_corpus a k-secventei
    ce o caut. Daca vectorul nu e gol atunci fac alt vector "word_poz_after_k"
    in care salvez pozitiile cuvintelor ce urmeaza dupa aceea k-secventa din
    textul inital(corpus_words).  Parcurg acest vector si pentru fiecare
    pozitie iau cuvantul din corpus_words caracteristic ei si apoi cu ajutorul
    dictionarului vad indexul acelui cuvant. In final incrementez elementul de
    pe pe linia i(ce reprezinta k-secventa) si coloan j (ce reprezinta cuvantul
    ce urmeaza dupa k-secventa) din matricea sparse.